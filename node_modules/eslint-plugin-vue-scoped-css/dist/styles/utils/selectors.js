"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasNodesSelector = hasNodesSelector;
exports.normalizePseudoParams = normalizePseudoParams;
exports.isVueSpecialPseudo = isVueSpecialPseudo;
exports.isVDeepPseudoV2 = isVDeepPseudoV2;
exports.isVDeepPseudo = isVDeepPseudo;
exports.isVSlottedPseudo = isVSlottedPseudo;
exports.isVGlobalPseudo = isVGlobalPseudo;
exports.isPseudoEmptyArguments = isPseudoEmptyArguments;
exports.isTypeSelector = isTypeSelector;
exports.isIDSelector = isIDSelector;
exports.isClassSelector = isClassSelector;
exports.isUniversalSelector = isUniversalSelector;
exports.isNestingSelector = isNestingSelector;
exports.isPseudo = isPseudo;
exports.isSelectorCombinator = isSelectorCombinator;
exports.isDescendantCombinator = isDescendantCombinator;
exports.isChildCombinator = isChildCombinator;
exports.isAdjacentSiblingCombinator = isAdjacentSiblingCombinator;
exports.isGeneralSiblingCombinator = isGeneralSiblingCombinator;
exports.isDeepCombinator = isDeepCombinator;
exports.isNestingAtRule = isNestingAtRule;
exports.findNestingSelectors = findNestingSelectors;
exports.findNestingSelector = findNestingSelector;
const ast_1 = require("../ast");
const css_nodes_1 = require("./css-nodes");
function hasNodesSelector(node) {
    return (node != null &&
        (node.type === "VCSSSelector" || node.type === "VCSSSelectorPseudo"));
}
function normalizePseudoParams(pseudo, nodes) {
    const results = [];
    let buffer = [];
    for (const node of nodes) {
        if (node.type === "VCSSSelector") {
            if (buffer.length) {
                const startNode = buffer[0];
                const endNode = buffer[buffer.length - 1];
                const loc = {
                    start: startNode.loc.start,
                    end: endNode.loc.end,
                };
                results.push(new ast_1.VCSSSelector(buffer[0], loc, startNode.start, endNode.end, {
                    parent: pseudo,
                    nodes: buffer,
                }));
                buffer = [];
            }
            results.push(node);
        }
        else {
            buffer.push(node);
        }
    }
    if (buffer.length) {
        const startNode = buffer[0];
        const endNode = buffer[buffer.length - 1];
        const loc = {
            start: startNode.loc.start,
            end: endNode.loc.end,
        };
        results.push(new ast_1.VCSSSelector(buffer[0], loc, startNode.start, endNode.end, {
            parent: pseudo,
            nodes: buffer,
        }));
        buffer = [];
    }
    return results;
}
function isVueSpecialPseudo(node) {
    return isVDeepPseudo(node) || isVSlottedPseudo(node) || isVGlobalPseudo(node);
}
function isVDeepPseudoV2(node) {
    if (isVDeepPseudo(node)) {
        return node.nodes.length === 0;
    }
    return false;
}
function isVDeepPseudo(node) {
    if (isPseudo(node)) {
        const val = node.value.trim();
        return val === "::v-deep" || val === ":deep";
    }
    return false;
}
function isVSlottedPseudo(node) {
    if (isPseudo(node)) {
        const val = node.value.trim();
        return val === "::v-slotted" || val === ":slotted";
    }
    return false;
}
function isVGlobalPseudo(node) {
    if (isPseudo(node)) {
        const val = node.value.trim();
        return val === "::v-global" || val === ":global";
    }
    return false;
}
function isPseudoEmptyArguments(node) {
    return (node.nodes.length === 0 ||
        (node.nodes.length === 1 && node.nodes[0].nodes.length === 0));
}
function isTypeSelector(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === "VCSSTypeSelector";
}
function isIDSelector(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === "VCSSIDSelector";
}
function isClassSelector(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === "VCSSClassSelector";
}
function isUniversalSelector(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === "VCSSUniversalSelector";
}
function isNestingSelector(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === "VCSSNestingSelector";
}
function isPseudo(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === "VCSSSelectorPseudo";
}
function isSelectorCombinator(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === "VCSSSelectorCombinator";
}
function isDescendantCombinator(node) {
    return isSelectorCombinator(node) && node.value.trim() === "";
}
function isChildCombinator(node) {
    return isSelectorCombinator(node) && node.value.trim() === ">";
}
function isAdjacentSiblingCombinator(node) {
    return isSelectorCombinator(node) && node.value.trim() === "+";
}
function isGeneralSiblingCombinator(node) {
    return isSelectorCombinator(node) && node.value.trim() === "~";
}
function isDeepCombinator(node) {
    if (isSelectorCombinator(node)) {
        const val = node.value.trim();
        return val === ">>>" || val === "/deep/";
    }
    return false;
}
function isNestingAtRule(node) {
    if (node == null) {
        return false;
    }
    return (0, css_nodes_1.isVCSSAtRule)(node) && node.name === "nest" && node.identifier === "@";
}
function* findNestingSelectors(nodes) {
    for (const node of nodes) {
        if (isNestingSelector(node)) {
            yield {
                nestingIndex: nodes.indexOf(node),
                node,
                nodes,
            };
        }
        if (hasNodesSelector(node)) {
            yield* findNestingSelectors(node.nodes);
        }
    }
}
function findNestingSelector(nodes) {
    for (const nest of findNestingSelectors(nodes)) {
        return nest;
    }
    return null;
}
